<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta name="DESCRIPTION" content="B-Trees in C++">
<meta name="KEYWORDS" content="B-Tree,B-Trees,Btree,Btrees,Multiway Tree,Multiway Search Tree,Successor,B+ Tree,B* Tree">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>CIS Department &gt; Tutorials &gt; Software Design Using C++ &gt; B-Trees</title>

<!-- Begin Header Code -->
<!--Fireworks 8 Dreamweaver 8 target.  Created Wed Jul 19 12:53:20 GMT-0400 (Eastern Standard Time) 2006-->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">

<script language="JavaScript1.2" type="text/javascript" src="btree_alt_cpp_fichiers/header.js"></script>
<style type="text/css" media="screen">
	@import url("/css/headernew.css");
	#bodyTable {width:800px;}
	#bodyTD {width:800px;}
	#underlineTD {background:url(/img/headerBullets.gif);}
</style>
<style type="text/css" media="all">
	@import url("/css/main.css");
</style>
<style type="text/css" media="print">
	#mainHeaderDIV {display:none;}
	/*#mainFooterDIV {display:none;}*/
	#underlineTD {display:none;}
	#bodyTable {width:670px;}
	#bodyTD {width:670px;}
</style>
</head>
<body>
<div id="mainHeaderDIV">
<div id="FWTableContainer316475368">
<img name="header" src="btree_alt_cpp_fichiers/header.png" id="header" usemap="#m_header" alt="" border="0" height="96" width="800">
<div style="float:right; cursor:pointer;" onclick="javascript:window.location='/html/search.html';" align="right"><h4>Search</h4></div>
<map name="m_header" id="m_header">
<area shape="rect" coords="5,3,50,47" href="http://cis.stvincent.edu/index.html">
<area shape="rect" coords="640,2,797,40" href="http://www.stvincent.edu/">
<area shape="rect" coords="697,62,797,95" href="http://cis.stvincent.edu/html/contactUs/index.html">
<area shape="rect" coords="614,62,693,95" onmouseout="MM_menuStartTimeout(200);" onmouseover="MM_menuShowMenu('MMMenuContainer0719124950_0', 'MMMenu0719124950_0',614,95,'header');">
<area shape="rect" coords="407,62,609,95" onmouseout="MM_menuStartTimeout(200);" onmouseover="MM_menuShowMenu('MMMenuContainer0719124759_1', 'MMMenu0719124759_1',407,95,'header');">
<area shape="rect" coords="253,62,403,95" onmouseout="MM_menuStartTimeout(200);" onmouseover="MM_menuShowMenu('MMMenuContainer0719115656_0', 'MMMenu0719115656_0',253,95,'header');">
<area shape="rect" coords="2,62,71,94" href="http://cis.stvincent.edu/index.html">
<area shape="rect" coords="75,62,249,95" onmouseout="MM_menuStartTimeout(200);" onmouseover="MM_menuShowMenu('MMMenuContainer0719112323_0', 'MMMenu0719112323_0',75,95,'header');">
</map>
<div style="visibility: inherit;" id="MMMenuContainer0719124950_0">
	<div style="visibility: hidden;" id="MMMenu0719124950_0" onmouseout="MM_menuStartTimeout(200);" onmouseover="MM_menuResetTimeout();">
		<a href="http://cis.stvincent.edu/carlsond/index.html" id="MMMenu0719124950_0_Item_0" class="MMMIFVStyleMMMenu0719124950_0" onmouseover="MM_menuOverMenuItem('MMMenu0719124950_0');">
			Br.&nbsp;David&nbsp;Carlson
		</a>
		<a href="http://cis.stvincent.edu/jodiss/index.html" id="MMMenu0719124950_0_Item_1" class="MMMIVStyleMMMenu0719124950_0" onmouseover="MM_menuOverMenuItem('MMMenu0719124950_0');">
			Dr.&nbsp;Stephen&nbsp;Jodis
		</a>
		<a href="http://cis.stvincent.edu/martincc/index.html" id="MMMenu0719124950_0_Item_2" class="MMMIVStyleMMMenu0719124950_0" onmouseover="MM_menuOverMenuItem('MMMenu0719124950_0');">
			Dr.&nbsp;Cynthia&nbsp;Martincic
		</a>
		<a href="http://cis.stvincent.edu/serapiglia/index.html" id="MMMenu0719124950_0_Item_3" class="MMMIVStyleMMMenu0719124950_0" onmouseover="MM_menuOverMenuItem('MMMenu0719124950_0');">
			Dr.&nbsp;Anthony&nbsp;Serapiglia
		</a>
	</div>
</div>
<div id="MMMenuContainer0719124759_1">
	<div id="MMMenu0719124759_1" onmouseout="MM_menuStartTimeout(200);" onmouseover="MM_menuResetTimeout();">
		<a href="http://cis.stvincent.edu/html/generalInformation/index.html" id="MMMenu0719124759_1_Item_0" class="MMMIFVStyleMMMenu0719124759_1" onmouseover="MM_menuOverMenuItem('MMMenu0719124759_1');">
			General&nbsp;CIS&nbsp;Information
		</a>
		<a href="http://cis.stvincent.edu/html/curriculum/index.html" id="MMMenu0719124759_1_Item_1" class="MMMIVStyleMMMenu0719124759_1" onmouseover="MM_menuOverMenuItem('MMMenu0719124759_1');">
			Curriculum
		</a>
		<a href="http://cis.stvincent.edu/html/events/index.html" id="MMMenu0719124759_1_Item_2" class="MMMIVStyleMMMenu0719124759_1" onmouseover="MM_menuOverMenuItem('MMMenu0719124759_1');">
			Events
		</a>
		<a href="http://cis.stvincent.edu/html/lab/index.html" id="MMMenu0719124759_1_Item_3" class="MMMIVStyleMMMenu0719124759_1" onmouseover="MM_menuOverMenuItem('MMMenu0719124759_1');">
			CIS&nbsp;Lab
		</a>
		<a href="http://cis.stvincent.edu/html/policies/index.html" id="MMMenu0719124759_1_Item_4" class="MMMIVStyleMMMenu0719124759_1" onmouseover="MM_menuOverMenuItem('MMMenu0719124759_1');">
			Department&nbsp;Policies
		</a>
		<a href="http://cis.stvincent.edu/html/grantsProjects/index.html" id="MMMenu0719124759_1_Item_5" class="MMMIVStyleMMMenu0719124759_1" onmouseover="MM_menuOverMenuItem('MMMenu0719124759_1');">
			Grants&nbsp;&amp;&nbsp;Projects
		</a>
	</div>
</div>
<div id="MMMenuContainer0719115656_0">
	<div id="MMMenu0719115656_0" onmouseout="MM_menuStartTimeout(200);" onmouseover="MM_menuResetTimeout();">
		<a href="http://cis.stvincent.edu/html/tutorials/index.html" id="MMMenu0719115656_0_Item_0" class="MMMIFVStyleMMMenu0719115656_0" onmouseover="MM_menuOverMenuItem('MMMenu0719115656_0');">
			Tutorials
		</a>
		<a href="http://cis.stvincent.edu/html/curriculum/index.html" id="MMMenu0719115656_0_Item_1" class="MMMIVStyleMMMenu0719115656_0" onmouseover="MM_menuOverMenuItem('MMMenu0719115656_0');">
			Curriculum
		</a>
		<a href="http://cis.stvincent.edu/html/lab/index.html" id="MMMenu0719115656_0_Item_2" class="MMMIVStyleMMMenu0719115656_0" onmouseover="MM_menuOverMenuItem('MMMenu0719115656_0');">
			CIS&nbsp;Lab
		</a>
		<a href="http://cis.stvincent.edu/html/events/index.html" id="MMMenu0719115656_0_Item_3" class="MMMIVStyleMMMenu0719115656_0" onmouseover="MM_menuOverMenuItem('MMMenu0719115656_0');">
			Events
		</a>
		<a href="http://cis.stvincent.edu/html/careersInternships/index.html" id="MMMenu0719115656_0_Item_4" class="MMMIVStyleMMMenu0719115656_0" onmouseover="MM_menuOverMenuItem('MMMenu0719115656_0');">
			Careers &amp; Internships
		</a>
		<a href="http://cis.stvincent.edu/html/scholarships/index.html" id="MMMenu0719115656_0_Item_5" class="MMMIVStyleMMMenu0719115656_0" onmouseover="MM_menuOverMenuItem('MMMenu0719115656_0');">
			Scholarships
		</a>
	</div>
</div>
<div style="visibility: inherit;" id="MMMenuContainer0719112323_0">
	<div style="visibility: hidden;" id="MMMenu0719112323_0" onmouseout="MM_menuStartTimeout(200);" onmouseover="MM_menuResetTimeout();">
		<a href="http://cis.stvincent.edu/html/whyComputing/index.html" id="MMMenu0719112323_0_Item_0" class="MMMIFVStyleMMMenu0719112323_0" onmouseover="MM_menuOverMenuItem('MMMenu0719112323_0');">
			Why&nbsp;Choose&nbsp;Computing?
		</a>
		<a href="http://cis.stvincent.edu/html/generalInformation/index.html" id="MMMenu0719112323_0_Item_1" class="MMMIVStyleMMMenu0719112323_0" onmouseover="MM_menuOverMenuItem('MMMenu0719112323_0');">
			General&nbsp;CIS&nbsp;Information
		</a>
		<a href="http://cis.stvincent.edu/html/curriculum/index.html" id="MMMenu0719112323_0_Item_2" class="MMMIVStyleMMMenu0719112323_0" onmouseover="MM_menuOverMenuItem('MMMenu0719112323_0');">
			Curriculum
		</a>
		<a href="http://cis.stvincent.edu/html/apExam/index.html" id="MMMenu0719112323_0_Item_3" class="MMMIVStyleMMMenu0719112323_0" onmouseover="MM_menuOverMenuItem('MMMenu0719112323_0');">
			AP&nbsp;Exam
		</a>
		<a href="http://cis.stvincent.edu/html/scholarships/index.html" id="MMMenu0719112323_0_Item_4" class="MMMIVStyleMMMenu0719112323_0" onmouseover="MM_menuOverMenuItem('MMMenu0719112323_0');">
			Scholarships
		</a>
		<a href="http://cis.stvincent.edu/html/contactUs/moreinformation.html" id="MMMenu0719112323_0_Item_5" class="MMMIVStyleMMMenu0719112323_0" onmouseover="MM_menuOverMenuItem('MMMenu0719112323_0');">
			Request&nbsp;More&nbsp;Information
		</a>
		<a href="http://www.stvincent.edu/Admission_and_Aid/Admissions_and_Aid/" id="MMMenu0719112323_0_Item_6" class="MMMIVStyleMMMenu0719112323_0" onmouseover="MM_menuOverMenuItem('MMMenu0719112323_0');">
			Apply&nbsp;Online
		</a>
	</div>
</div>
</div>
</div>
<table id="bodyTable" border="0" cellpadding="0" cellspacing="0">
	<tbody><tr>
		<td id="bodyTD"><br>
<!-- End Header Code -->


<!-- Begin Page Content -->
<h2>Software Design Using C++</h2>
<br><table cellpadding="0" cellspacing="0" height="1" width="100%"><tbody><tr><td id="underlineTD" style="background: url(&quot;/img/headerBullets.gif&quot;) repeat scroll 0% 0% transparent;"><img src="btree_alt_cpp_fichiers/headerBullets.gif" height="1" width="4"></td></tr></tbody></table><table border="0"><tbody><tr><td></td></tr></tbody></table>

<br>
<h3>B-Trees</h3>

<br><br>
<h3>Introduction</h3>
<br>
A B-tree is a specialized multiway tree designed especially for use on disk.
In a B-tree each node may contain a large number of keys.  The number of
subtrees of each node, then, may also be large.  A B-tree is designed to
branch out in this large number of directions and to contain a lot of
keys in each node so that the height of the tree is relatively small.  This
means that only a small number of nodes must be read from disk to retrieve
an item.  The goal is to get fast access to the data, and with disk drives
this means reading a very small number of records.  Note that a large node
size (with lots of keys in the node) also fits with the fact that with a
disk drive one can usually read a fair amount of data at once.

<br><br>
<h3>Definitions</h3>
<br>
A <strong>multiway tree of order m</strong> is an ordered tree
where each node has at most
m children.  For each node, if k is the actual number of children in the
node, then k - 1 is the number of keys in the node.  If the keys and 
subtrees are arranged in the fashion of a search tree, then this is called
a <strong>multiway search tree of order m</strong>.
For example, the following is a multiway
search tree of order 4.  Note that the first row in each node shows the keys,
while the second row shows the pointers to the child nodes.  Of course, in
any useful application there would be a record of data associated with each
key, so that the first row in each node might be an array of records where
each record contains a key and its associated data.  Another approach
would be to have the first row of each node contain an array of records where each
record contains a key and a record number for the associated data record,
which is found in another file.  This last method is often used when
the data records are large.  The example software will use the first method.

<p>
<img src="btree_alt_cpp_fichiers/multiway.gif" alt="[multiway search tree]">
</p>

<p>
What does it mean to say that the keys and subtrees are "arranged in the
fashion of a search tree"?  Suppose that we define our nodes as follows:
</p>

<table class="generalLinedTable" cellpadding="6" cellspacing="0">
<tbody><tr><td><pre><code>
typedef struct
   {
   int Count;         // number of keys stored in the current node
   ItemType Key[3];   // array to hold the 3 keys
   long Branch[4];    // array of fake pointers (record numbers)
   } NodeType;
</code></pre></td></tr>
</tbody></table>

<br>
Then a multiway search tree of order 4 has to fulfill the following
conditions related to the ordering of the keys:
<table border="0"><tbody><tr><td>
<ul>
   <li>The keys in each node are in ascending order.</li>
   <li>At every given node (call it Node) the following is true:
      <ul>
         <li>The subtree starting at record Node.Branch[0] has only keys that
            are less than Node.Key[0].</li>
         <li>The subtree starting at record Node.Branch[1] has only keys that
            are greater than Node.Key[0] and at the same time less than
            Node.Key[1].</li>
         <li>The subtree starting at record Node.Branch[2] has only keys that
            are greater than Node.Key[1] and at the same time less than
            Node.Key[2].</li>
         <li>The subtree starting at record Node.Branch[3] has only keys that
            are greater than Node.Key[2].</li>
      </ul>
   </li>
   <li>Note that if less than the full number of keys are in the Node,
      these 4 conditions are truncated so that they speak of the appropriate
      number of keys and branches.</li>
</ul>
</td></tr></tbody></table>

This generalizes in the obvious way to multiway search trees with other orders.

<br><br>
A B-tree of order m is a multiway search tree of order m such that:
<table border="0"><tbody><tr><td>
<ul>
   <li>All leaves are on the bottom level.</li>
   <li>All internal nodes (except perhaps the root node)
      have at least ceil(m / 2) (nonempty) children.</li>
   <li>The root node can have as few as 2 children if it is an internal node,
      and can obviously have no children if the root node is a leaf
      (that is, the whole tree consists only of the root node).</li>
   <li>Each leaf node (other than the root node if it is a leaf)
      must contain at least ceil(m / 2) - 1 keys.</li>
</ul>
</td></tr></tbody></table>

Note that ceil(x) is the so-called ceiling function.  It's value is the
smallest integer that is greater than or equal to x.  Thus ceil(3) = 3,
ceil(3.35) = 4, ceil(1.98) = 2, ceil(5.01) = 6, ceil(7) = 7, etc.

<p>
A B-tree is a fairly well-balanced tree by virtue of the fact that all
leaf nodes must be at the bottom.  Condition (2) tries to keep the tree
fairly bushy by insisting that each node have at least half the maximum
number of children.  This causes the tree to "fan out" so that the path
from root to leaf is very short even in a tree that contains a lot of data.
</p>

<h3>Example B-Tree</h3>
<br>
The following is an example of a B-tree of order 5.  This means that (other
that the root node) all internal nodes have at least ceil(5 / 2) = ceil(2.5) =
3 children (and hence at least 2 keys).  Of course, the maximum number of
children that a node can have is 5 (so that 4 is the maximum number of keys).
According to condition 4, each leaf node must contain at least 2 keys.
In practice B-trees usually have orders a lot bigger than 5.

<p>
<img src="btree_alt_cpp_fichiers/btree1.gif" alt="[B-tree]">
</p>

<h3>Operations on a B-Tree</h3>
<br>
Question:  How would you search in the above tree to look up S?  How about J?
How would you do a sort-of "in-order" traversal, that is, a traversal that
would produce the letters in ascending order?  (One would only do such a
traversal on rare occasion as it would require a large amount of disk
activity and thus be very slow!)

<br><br>
<h4>Inserting a New Item</h4>
<br>
According to Kruse (see reference at the end of this file) the insertion
algorithm proceeds as follows:  When inserting an item, first do a search
for it in the B-tree.  If the item is not already in the B-tree, this
unsuccessful search will end at a leaf.  If there is room in this leaf,
just insert the new item here.  Note that this may require that some existing
keys be moved one to the right to make room for the new item.  If instead
this leaf node is full so that there is no room to add the new item, then
the node must be "split" with about half of the keys going into a new node
to the right of this one.  The median (middle) key is moved up into the
parent node.  (Of course, if that node has no room, then it may have to be
split as well.)  Note that when adding to an internal node, not only might
we have to move some keys one position to the right, but the associated
pointers have to be moved right as well.  If the root node is ever split,
the median key moves up into a new root node, thus causing the tree to
increase in height by one.

<p>
Let's work our way through an example similar to that given by Kruse.
Insert the following letters into what is originally
an empty B-tree of order 5: C N G A H E K Q M F W L T Z D P R X Y S
Order 5 means that a node can have a maximum of 5 children and 4 keys.
All nodes other than the root must have a minimum of 2 keys.  The first
4 letters get inserted into the same node, resulting in this picture:
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreea.gif" alt="[B-tree]">
</p>

<p>
When we try to insert the H, we find no room in this node, so we split it
into 2 nodes, moving the median item G up into a new root node.  Note that
in practice we just leave the A and C in the current node and place the H
and N into a new node to the right of the old one.
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreeb.gif" alt="[B-tree]">
</p>

<p>
Inserting E, K, and Q proceeds without requiring any splits:
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreec.gif" alt="[B-tree]">
</p>

<p>
Inserting M requires a split.  Note that M happens to be the median key
and so is moved up into the parent node.
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreed.gif" alt="[B-tree]">
</p>

<p>
The letters F, W, L, and T are then added without needing any split.
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreee.gif" alt="[B-tree]">
</p>

<p>
When Z is added, the rightmost leaf must be split.  The median item T is
moved up into the parent node.  Note that by moving up the median key, the
tree is kept fairly balanced, with 2 keys in each of the resulting nodes.
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreef.gif" alt="[B-tree]">
</p>

<p>
The insertion of D causes the leftmost leaf to be split.  D happens to be
the median key and so is the one moved up into the parent node.  The
letters P, R, X, and Y are then added without any need of splitting:
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreeg.gif" alt="[B-tree]">
</p>

<p>
Finally, when S is added, the node with N, P, Q, and R splits, sending the
median Q up to the parent.  However, the parent node is full, so it splits,
sending the median M up to form a new root node.  Note how the 3 pointers
from the old parent node stay in the revised node that contains D and G.
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreeh.gif" alt="[B-tree]">
</p>

<h4>Deleting an Item</h4>
<br>
In the B-tree as we left it at the end of the last section, delete H.  Of
course, we first do a lookup to find H.  Since H is in a leaf and the leaf has
more than the minimum number of keys, this is easy.  We move the K over where
the H had been and the L over where the K had been.  This gives:

<p>
<img src="btree_alt_cpp_fichiers/btreei.gif" alt="[B-tree]">
</p>

<p>
Next, delete the T.  Since T is not in a leaf, we find its successor (the
next item in ascending order), which happens to be W, and move W up to
replace the T.  That way, what we really have to do is to delete W from the
leaf, which we already know how to do, since this leaf has extra keys.
In ALL cases we reduce deletion to a deletion in a leaf, by using this method.
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreej.gif" alt="[B-tree]">
</p>

<p>
Next, delete R.  Although R is in a leaf, this leaf does not have an extra
key; the deletion results in a node with only one key, which is not acceptable
for a B-tree of order 5.  If the sibling node to the immediate left or
right has an extra key, we can then borrow a key from the parent and move
a key up from this sibling.  In our specific case, the sibling to the right
has an extra key.  So, the successor W of S (the last key in the node where
the deletion occurred), is moved down from the parent, and the X is moved up.
(Of course, the S is moved over so that the W can be inserted in its proper place.)
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreek.gif" alt="[B-tree]">
</p>

<p>
Finally, let's delete E.  This one causes lots of problems.  Although E is
in a leaf, the leaf has no extra keys, nor do the siblings to the immediate
right or left.  In such a case the leaf has to be combined with one of
these two siblings.  This includes moving down the parent's key that was
between those of these two leaves.  In our example, let's combine the leaf
containing F with the leaf containing A C.  We also move down the D.
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreel.gif" alt="[B-tree]">
</p>

<p>
Of course, you immediately see that the parent node now contains only one key,
G.  This is not acceptable.  If this problem node had a sibling to its
immediate left or right that had a spare key, then we would again "borrow"
a key.  Suppose for the moment that the right sibling (the node with Q X)
had one more key in it somewhere to the right of Q.
We would then move M down to the node with too few
keys and move the Q up where the M had been.  However, the old left subtree of
Q would then have to become the right subtree of M.  In other words, the
N P node would be attached via the pointer field to the right of M's new
location.  Since in our example we have no way to borrow a key from a sibling,
we must again combine with the sibling, and move down the M from the parent.
In this case, the tree shrinks in height by one.
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreem.gif" alt="[B-tree]">
</p>

<h4>Another Example</h4>
<br>
Here is a different B-tree of order 5.  Let's try to delete C from it.

<p>
<img src="btree_alt_cpp_fichiers/btreen.gif" alt="[B-tree]">
</p>

<p>
We begin by finding the immediate successor, which would be D, and move the
D up to replace the C.  However, this leaves us with a node with too few keys.
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreeo.gif" alt="[B-tree]">
</p>

<p>
Since neither the sibling to the left or right of the node containing E has
an extra key, we must combine the node with one of these two siblings.  Let's
consolidate with the A B node.
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreep.gif" alt="[B-tree]">
</p>

<p>
But now the node containing F does not have enough keys.  However, its
sibling has an extra key.  Thus we borrow the M from the sibling, move it
up to the parent, and bring the J down to join the F.  Note that the K L
node gets re-attached to the right of the J.
</p>

<p>
<img src="btree_alt_cpp_fichiers/btreeq.gif" alt="[B-tree]">
</p>

<h3><a name="Table"></a>A B-Tree Example</h3>
<br>
The following is a completely coded example.  There are two programs: btmake
to create a B-Tree table and btread to allow the user to look up (read) items
from a B-Tree table.  In this example, each key is a word and the associated
data is the definition of the word.  The coding details are rather complicated.  See the
Kruse book from the references section for some of the details, but be aware
that our example does not follow that book's code in all respects.
You might want to compare this example to our
<a href="http://cis.stvincent.edu/html/tutorials/swd/lists/listtabl.html">List-Based Table</a> example and to our
<a href="http://cis.stvincent.edu/html/tutorials/swd/bintrees/bintrees.html#Table">Binary Search Tree Based Table</a> example.
<table border="0"><tbody><tr><td>
<ul>
   <li><a href="http://cis.stvincent.edu/html/tutorials/swd/btree/itemtype.h">itemtype.h</a></li>
   <li><a href="http://cis.stvincent.edu/html/tutorials/swd/btree/table.h">table.h</a> (sets up an abstract base class for tables)</li>
   <li><a href="http://cis.stvincent.edu/html/tutorials/swd/btree/btree.h">btree.h</a> (derives a B-Tree table class)</li>
   <li><a href="http://cis.stvincent.edu/html/tutorials/swd/btree/btree.cpp">btree.cpp</a></li>
   <li><a href="http://cis.stvincent.edu/html/tutorials/swd/btree/btree.txt">btree.txt</a> (text file of data to use)</li>
   <li><a href="http://cis.stvincent.edu/html/tutorials/swd/btree/btmake.cpp">btmake.cpp</a> (creates a B-Tree table)</li>
   <li><a href="http://cis.stvincent.edu/html/tutorials/swd/btree/btread.cpp">btread.cpp</a> (reads data from a B-Tree table)</li>
</ul>
</td></tr></tbody></table>

In btree.h you will notice that we are making a B-Tree of order 12.
Furthermore, each node of the B-Tree is a record containing an array of keys
(actually keys and associated data), an array of child pointers (record numbers),
as well as a count of how many keys are actually stored in this node.  The latter
is needed since a node might not be completely filled with keys.

<p>
In the same file you will find the class declaration for BTTableClass.
Note that there are four data fields listed: the record number for the root node,
the count of how many nodes are in the B-Tree, the number of bytes per node
(needed whenever we do input/output of a node), and a field to hold the
entire current node that we are working with.  This last field gives us
a handy place to put the node data that we are working on at any given point.
Remember that objects of this class inherit three data fields from the abstract
base class: the file stream, the number of items (consisting of a word and its definition)
in the table, and a character indicating if we opened the table in read or write mode.
You can see many of the details of one of these objects and its associated data
file in a <a href="http://cis.stvincent.edu/html/tutorials/swd/btree/btreetable.gif">separate drawing</a>.  If you prefer, use
the <a href="http://cis.stvincent.edu/html/tutorials/swd/btree/btreetable2.gif">larger version of this drawing</a>.
</p>

Note how the definition of DEBUG can be commented off in btree.h.  Make sure
it is uncommented if you want to run the debugging code that has been included.
Look at the functions Dump, Check, and CheckSubtree for further details.
In btmake.cpp note how the Load function checks to see if DEBUG has been
defined and if so, executes certain debugging code.  Even in btree.cpp there
is some debugging code that is conditionally compiled depending on whether or
not DEBUG is defined.  Here, the debugging code prints a dump of the whole
B-Tree when the program ends and during the program
prints a single letter at key points as a sign of what
operation is being performed.  The letters and their meanings are as follows:
<table border="0"><tbody><tr><td>
<ul>
   <li>R - doing a read from the file</li>
   <li>W - doing a write to the file</li>
   <li>P - PushDown is being executed</li>
   <li>I - Insert is being executed</li>
   <li>S - Split is being executed</li>
</ul>
</td></tr></tbody></table>

No attempt is made here to explain all of the details of this example program, as it
is fairly long and involved.  A detailed explanation of the
<a href="http://cis.stvincent.edu/html/tutorials/swd/btree/retrieve.html">B-Tree retrieve function</a> is available in order to
illustrate some of the workings of this program.  The reader can examine the other
functions more carefully if desired.  Most of the functions are actually fairly
straight-forward with the exception of the PushDown function, which is rather complex.

<br><br>
<h3>Variations</h3>
<br>
According to Shaffer (see the references at the end of this file), the 
B-tree and variations on it are commonly used in large commercial databases
to provide quick access to the data.  In fact, he says that they are "the
standard file organization for applications requiring insertion, deletion,
and key range searches".  The variant called the B+ tree is the usual one.
Another variant is the B* tree, which is very similar to the B+ tree, but
tries to keep the nodes about two-thirds full at a minimum.

<p>
In a B+ tree, data records are only stored in the leaves.  Internal nodes
store just keys.  These keys are used for directing a search to the proper leaf.
If a target key is less than a key in an internal node, then the pointer
just to its left is followed.  If a target key is greater or equal to the
key in the internal node, then the pointer just to its right is followed.
The leaves are also linked together so that all of the keys in the
B+ tree can be traversed in ascending order, just by going through all of
the nodes in this linked list along the bottom level of the tree.
</p>

<p>
When a B+ tree is implemented on disk, it is likely that the leaves
contain key, pointer pairs where the pointer field points to the record of
data associated with the key.  This allows the data file to exist separately
from the B+ tree, which functions as an "index" giving an ordering to the
data in the data file.  This is how B+ trees are used in a database.  Of
course, the pointers are record numbers, our typical fake pointers used
when creating dynamic data structures on disk.  Notice that this B+ tree
indexing scheme allows one data file to have several such indices, each giving
an ordering by a different key field, something highly desirable to have.
</p>

<p>
As an example, consider a B+ tree of order 200, whose leaves can each contain
up to 199 keys (approximately 200).  Let's assume that the root node has
at least 100 children (though we know it is allowed to have as few as two). 
A 2 level B+ tree that meets these assumptions can store up to about 10,000
records, since there are at least 100 leaves, each containing at least 99
keys (approximately 100).  A 3 level B+ tree of this type
can store up to about 1 million keys.  A 4 level B+ tree can
store up to about 100 million keys.  To get faster access to the data, the
root node is commonly kept in main memory.  Maybe even the child nodes
of the root can fit in main memory.  Thus one can find one of 100 million
keys with only 2 or 3 disk reads.  If, as is common, the associated data
records are stored in a separate file, there is one additional read to
get the data associated with a key.  Also, note that if the root node
has fewer that our assumed 100 children, this slows down the lookup further.
</p>

<h3>References:</h3>
<table border="0"><tbody><tr><td>
<ul>
   <li><u>Data Structures &amp; Program Design</u>, 2nd ed. Robert L. Kruse.
      Prentice-Hall (1987). There is also a third edition (1994) as well
      as a new text, <u>Data Structures and Program Design in C++</u>,
      authored by Kruse and Alexander J. Ryba (1999).</li>

   <li><u>Data Structures Using Pascal</u>, 2nd ed.
      Aaron M. Tenenbaum, Moshe J. Augenstein.  Prentice-Hall (1986).</li>

   <li><u>A Practical Introduction to Data Structures and Algorithm Analysis</u>.
      Clifford A. Shaffer.  Prentice-Hall (1997).</li>

   <li><u>Introduction to Algorithms</u>.  Thomas H. Cormen, Charles E.
      Leiserson, and Ronald L. Rivest.  McGraw-Hill (1990).  See chapter 19.</li>
</ul>
</td></tr></tbody></table>

<h3>Related Items:</h3>
<table border="0"><tbody><tr><td>
<ul>
   <li><a href="http://cis.stvincent.edu/html/tutorials/swd/lists/listtabl.html">A List-Based Table</a></li>
   <li><a href="http://cis.stvincent.edu/html/tutorials/swd/bintrees/bintrees.html">Binary Trees</a></li>
   <li><a href="http://cis.stvincent.edu/html/tutorials/swd/stl/maps/maps.html">Maps (in STL)</a></li>
</ul>
</td></tr></tbody></table>

<a href="http://cis.stvincent.edu/html/tutorials/swd/index.html">Back to the main page for <i>Software Design Using C++</i></a>

<br><br>
<!-- End Page Content -->

<!-- Begin Footer Code -->
			<div id="mainFooterDIV">
				
				<img src="btree_alt_cpp_fichiers/footer.gif">
				<small>
					
						Authors: <a href="http://cis.stvincent.edu/carlsond/index.html">Br. David Carlson</a>
                                                and Br. Isidore Minerd<br>
						Last updated: August 27, 2009
					
				</small>
			</div>
		</td>
	</tr>
</tbody></table>




</body></html>
<!-- End Footer Code -->